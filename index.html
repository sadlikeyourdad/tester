<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Linux Process-Tree Viewer</title>

  <!-- deps -->
  <link href="https://unpkg.com/vis-network@9.1.2/styles/vis-network.min.css" rel="stylesheet"/>
  <script src="https://unpkg.com/vis-network@9.1.2/dist/vis-network.min.js"></script>
  <script src="https://unpkg.com/elkjs@0.7.1/lib/elk.bundled.js"></script>

  <!-- minimal mac-style theme -->
  <style>
    :root{--bg:#f2f2f7;--sidebar:#ffffffd2;--header:#fbfbfdcc;--border:#d9d9e0;
          --mono:#636366;--blue:#0a84ff;--orange:#ff8f28;--yellow:#ffd964;--red:#ff453a}
    *{box-sizing:border-box;margin:0;padding:0}
    body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;
         background:var(--bg);height:100vh;display:flex;flex-direction:column;color:#1c1c1e}
    header{display:flex;align-items:center;gap:1rem;padding:.65rem 1.25rem;
           backdrop-filter:blur(14px);background:var(--header);border-bottom:1px solid var(--border)}
    header .title{font-size:1.25rem;font-weight:600}
    header input[type=file]{display:none}
    label.file-btn{padding:.45rem .9rem;border:1px solid var(--border);border-radius:10px;background:#fff;cursor:pointer}
    #searchInput{flex:0 0 240px;padding:.45rem .9rem;border:1px solid var(--border);border-radius:10px;background:#fff}

    #layout{flex:1;display:flex;min-height:0}
    #network{flex:3;min-width:0}
    #details{flex:1;min-width:260px;overflow-y:auto;padding:1.25rem;background:var(--sidebar);
             border-left:1px solid var(--border);backdrop-filter:blur(28px)}
    #details h3{font-size:1.1rem;font-weight:600;margin-bottom:.25rem}
    #details .pid-badge{font-size:.8rem;color:var(--mono)}
    #details dt{font-weight:600;margin-top:.45rem;font-size:.83rem;color:#3a3a3c}
    #details dd{margin:.1rem 0 .5rem .1rem;word-break:break-word;font-size:.83rem}
    #details code{font-family:"SF Mono",Consolas,Menlo,monospace;background:#f6f6f8;border-radius:6px;
                 padding:2px 5px;color:#1c1c1e}
    details.event-group{margin-top:1rem}details.event-group summary{cursor:pointer;font-weight:600}
    ul{margin-left:1.1rem;list-style:circle;font-size:.83rem}

    /* timeline bar */
    footer{padding:.5rem 1.25rem;border-top:1px solid var(--border);background:var(--header);
           backdrop-filter:blur(14px);display:flex;align-items:center;gap:.75rem}
    #timeSlider{flex:1;width:100%}
    #timeLabel{font-size:.85rem;color:var(--mono);min-width:140px;text-align:right}

    /* loading overlay */
    #overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
             background:rgba(249,249,251,.6);backdrop-filter:blur(4px);font-size:1.05rem;color:var(--mono);
             z-index:999;visibility:hidden}
    .spinner{width:28px;height:28px;border:4px solid var(--blue);border-top-color:transparent;border-radius:50%;
             margin-right:.9rem;animation:spin 1s linear infinite}@keyframes spin{to{transform:rotate(360deg)}}
    .vis-network{background:transparent}
    .tag{display:inline-block;font-size:.65rem;font-weight:600;padding:2px 6px;border-radius:4px;color:#fff;margin-right:.35rem}
    .read{background:var(--blue)}
    .write{background:var(--orange)}.unknown{background:var(--mono)}
  </style>
</head>
<body>
<header>
  <span class="title">Linux Process-Tree Viewer</span>
  <label class="file-btn">Load JSON<input type="file" id="fileInput" accept=".json,.log,.txt"></label>
  <input id="searchInput" type="search" placeholder="Search process / PID">
</header>

<div id="layout">
  <div id="network"></div>
  <div id="details"><em>Select a process node to view details.</em></div>
</div>

<!-- timeline -->
<footer>
  <input id="timeSlider" type="range" min="0" max="100" value="100" step="1">
  <span id="timeLabel">â</span>
</footer>

<div id="overlay"><div class="spinner"></div><span id="overlayText">Loadingâ¦</span></div>

<script>
/* âââ config & helpers âââââââââââââââââââââââââââââââââââââââââââââââ */
const ROOT='systemd',H=40,CHAR=8,MINW=120;
const rootCol =()=>({background:'#d1e3ff',border:'#3c71ff'});
const normCol =()=>({background:'#ffffff',border:'#d4d4d8'});
const fileCol =()=>({background:'#e8fafa',border:'#24c0be'});
const hitCol  =()=>({background:'#ffd964',border:'#ffd200'});
const pathCol =()=>({background:'#ffeceb',border:'#ff453a'});
const $ = id=>document.getElementById(id);
const esc=s=>s.replace(/[&<>"]/g,ch=>({'&':'&','<':'<','>':'>','"':'"'}[ch]));
const basename=p=>p?.split('/').pop()||'';

/* DOM refs */
const netDiv=$('network'),details=$('details'),overlay=$('overlay'),overlayTxt=$('overlayText'),
      fileInput=$('fileInput'),searchInput=$('searchInput'),
      slider=$('timeSlider'),timeLabel=$('timeLabel');

let network,nodesDS,edgesDS,procMap=new Map(),nodeTime=new Map(),edgeTime=new Map(),
    minTs=Infinity,maxTs=-Infinity;

/* overlay helpers */
const show=txt=>{overlayTxt.textContent=txt;overlay.style.visibility='visible'};
const hide=()=>overlay.style.visibility='hidden';

/* load file */
fileInput.addEventListener('change',e=>{
  const f=e.target.files[0];if(!f)return;
  show('Reading fileâ¦');
  const r=new FileReader();r.onload=ev=>setTimeout(()=>buildTree(ev.target.result),24);r.readAsText(f);
});
searchInput.addEventListener('input',refreshColors);

/* âââ buildTree ââââââââââââââââââââââââââââââââââââââââââââââââââââââ */

async function buildTree(text) {
  show('Parsing eventsâ¦');

  /* ---------- state ---------- */
  procMap  = new Map();
  nodeTime = new Map();
  edgeTime = new Map();
  minTs    =  Infinity;
  maxTs    = -Infinity;

  const ROOT_ID = ROOT;
  up(ROOT_ID).meta = { binary: ROOT_ID, pid: 0 };

  /* ---------- helpers ---------- */
  function remember(id, ts) {
    if (isNaN(ts)) return;
    if (!nodeTime.has(id) || ts < nodeTime.get(id)) nodeTime.set(id, ts);
    minTs = Math.min(minTs, ts);
    maxTs = Math.max(maxTs, ts);
  }
  function up(id) {
    return (
      procMap.get(id) ||
      procMap.set(id, { meta: null, parent: ROOT_ID, files: [], nets: [] }).get(id)
    );
  }

  /* ---------- 1. parse each line individually ---------- */
  const lines = text.split(/\r?\n/);
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line) continue;
    let ev;
    try {
      ev = JSON.parse(line);
    } catch {
      continue;
    }
    const ts = Date.parse(ev.time || '');
    if (isNaN(ts)) continue;

    /* ------------ exec / exit ------------ */
    if (ev.process_exec || ev.process_exit) {
      const child  = (ev.process_exec || ev.process_exit).process;
      const parent = (ev.process_exec || ev.process_exit).parent;

      const c = up(child.exec_id);
      c.meta = child;
      c.parent = child.parent_exec_id || ROOT_ID;
      remember(child.exec_id, ts);

      if (parent) {
        const p = up(parent.exec_id);
        p.meta ??= parent;
        p.parent ??= parent.parent_exec_id || ROOT_ID;
        remember(parent.exec_id, ts);
      }
    } else {
      /* ------------ file / net / kprobe ------------ */
      const jsonStr = JSON.stringify(ev);
      const isFile = /file_arg|file_event|security_file|fs/i.test(jsonStr);
      const isNet = /net|connect|l3_l4/i.test(jsonStr);
      if (!isFile && !isNet) continue;

      const procObj =
        ev.process ||
        ev.process_kprobe?.process ||
        ev.l3_l4?.process ||
        ev.file_event?.process;

      const parentObj =
        ev.process_kprobe?.parent ||
        ev.l3_l4?.parent ||
        ev.file_event?.parent;

      const id = procObj?.exec_id;
      if (!id) continue;

      const rec = up(id);
      if (!rec.meta && procObj) {
        rec.meta = procObj;
        rec.parent = procObj.parent_exec_id || parentObj?.exec_id || ROOT_ID;
      }
      if (procObj?.parent_exec_id && rec.parent === ROOT_ID)
        rec.parent = procObj.parent_exec_id;

      if (parentObj) {
        const pr = up(parentObj.exec_id);
        pr.meta ??= parentObj;
        pr.parent ??= parentObj.parent_exec_id || ROOT_ID;
        remember(parentObj.exec_id, ts);
      }

      if (isFile) rec.files.push(ev);
      if (isNet) rec.nets.push(ev);

      remember(id, ts);
    }

    if (i % 100 === 0) {
      show(`Parsing events... (${i} / ${lines.length})`);
      await new Promise(r => setTimeout(r, 0)); // Yield to UI
    }
  }

  show('Processing complete. Building graph...');

  /* ensure every node has a timestamp */
  procMap.forEach((_, id) => {
    if (!nodeTime.has(id)) nodeTime.set(id, minTs);
  });

  /* ---------- 2. choose layout: ELK â¤1200, vis-hierarchical otherwise ---------- */
  const NODE_COUNT = procMap.size;
  const USE_ELK = NODE_COUNT <= 1200;

  const elkNodes = [],
    elkEdges = [],
    width = {};
  procMap.forEach((p, id) => {
    const main = id === ROOT_ID ? ROOT_ID : p.meta?.binary?.split('/').pop() || id.slice(0, 8);
    const sub = id === ROOT_ID ? '' : `PID ${p.meta?.pid ?? '?'}`;
    width[id] = Math.max(MINW, Math.max(main.length, sub.length) * CHAR + 24);
    elkNodes.push({ id, width: width[id], height: H });

    if (id !== ROOT_ID) {
      const par = p.parent && procMap.has(p.parent) ? p.parent : ROOT_ID;
      elkEdges.push({ id: `${par}->${id}`, sources: [par], targets: [id] });
      edgeTime.set(`${par}->${id}`, nodeTime.get(id));
    }
  });

  let layout;
  if (USE_ELK) {
    show('Computing layout (ELK)â¦');
    const elk = new ELK();
    layout = await elk.layout({
      id: 'root',
      layoutOptions: {
        'elk.algorithm': 'layered',
        'elk.direction': 'RIGHT',
        'elk.edgeRouting': 'ORTHOGONAL',
        'elk.spacing.nodeNode': '48',
        'elk.layered.spacing.nodeNodeBetweenLayers': '48'
      },
      children: elkNodes,
      edges: elkEdges
    });
  }

  /* ---------- 3. build vis datasets ---------- */
  const pos = {};
  if (USE_ELK) {
    layout.children.forEach(
      (n) => (pos[n.id] = { x: n.x + width[n.id] / 2, y: n.y + H / 2 })
    );
  }

  const vNodes = [],
    vEdges = [];
  procMap.forEach((p, id) => {
    const w = width[id],
      root = id === ROOT_ID,
      hasF = p.files.length;
    const { x, y } = USE_ELK ? pos[id] : { x: undefined, y: undefined };

    vNodes.push({
      id,
      label: root
        ? ROOT_ID
        : `${p.meta?.binary?.split('/').pop() || id.slice(0, 8)}\nPID ${p.meta?.pid ?? '?'}`,
      shape: root ? 'ellipse' : 'box',
      font: { multi: 'html', bold: root },
      borderRadius: 12,
      widthConstraint: { minimum: w },
      color: root ? rootCol() : hasF ? fileCol() : normCol(),
      x,
      y,
      fixed: USE_ELK ? { x: true, y: true } : false
    });

    ['_in', '_out'].forEach((pt) => {
      const dx = pt === '_in' ? -w / 2 : w / 2;
      vNodes.push({
        id: id + pt,
        shape: 'dot',
        size: 1,
        color: 'rgba(0,0,0,0)',
        physics: false,
        x: USE_ELK ? x + dx : undefined,
        y: USE_ELK ? y : undefined,
        fixed: USE_ELK ? { x: true, y: true } : false
      });
    });
  });

  elkEdges.forEach((e) =>
    vEdges.push({
      id: e.id,
      from: e.sources[0] + '_out',
      to: e.targets[0] + '_in',
      color: '#8e8e93',
      width: 1.2
    })
  );

  nodesDS = new vis.DataSet(vNodes);
  edgesDS = new vis.DataSet(vEdges);

  network?.destroy();
  network = new vis.Network(
    netDiv,
    { nodes: nodesDS, edges: edgesDS },
    {
      physics: !USE_ELK,
      layout: USE_ELK
        ? undefined
        : { hierarchical: { direction: 'LR', levelSeparation: 100, nodeSpacing: 120 } },
      edges: { smooth: false },
      interaction: { hover: true, navigationButtons: true, keyboard: true }
    }
  );

  network.on('selectNode', (ev) => {
    const id = ev.nodes[0];
    if (!id || id.endsWith('_in') || id.endsWith('_out')) {
      clearPath();
      return;
    }
    showDetails(id);
    refreshColors();
    paintPath(id);
  });
  network.on('deselectNode', clearPath);

  /* ---------- 4. discrete timeline ---------- */
  const tsArr = [...new Set([...nodeTime.values(), ...edgeTime.values()])].sort(
    (a, b) => a - b
  );

  slider.min = 0;
  slider.max = tsArr.length - 1;
  slider.step = 1;
  slider.value = slider.max;
  timeLabel.textContent = new Date(tsArr[slider.max]).toLocaleString();

  let raf = null;
  slider.oninput = () => {
    const idx = +slider.value;
    if (raf) cancelAnimationFrame(raf);
    raf = requestAnimationFrame(() => {
      applyTimeline(tsArr[idx]);
      timeLabel.textContent = new Date(tsArr[idx]).toLocaleString();
      raf = null;
    });
  };

  applyTimeline(tsArr[slider.max]);
  hide();
}

/* ---------- timeline filter ------------------------------------------ */
function applyTimeline(wallMs) {
  /* hide / show nodes */
  nodesDS.forEach(n => {
    if (n.id.endsWith('_in') || n.id.endsWith('_out')) return;
    const hide = nodeTime.get(n.id) > wallMs;
    nodesDS.update([{ id: n.id,          hidden: hide },
                    { id: n.id + '_in',  hidden: hide },
                    { id: n.id + '_out', hidden: hide }]);
  });

  /* hide / show edges */
  edgesDS.forEach(e => {
    const hide = edgeTime.get(e.id) > wallMs ||
                 nodesDS.get(e.from.replace(/_out$/, ''))?.hidden ||
                 nodesDS.get(e.to  .replace(/_in$/,  ''))?.hidden;
    edgesDS.update({ id: e.id, hidden: hide });
  });

  refreshColors();      // keep search / highlight colours in sync
}

/* ---------- colouring/search/path ------------------------------------ */
function refreshColors(){
  if(!nodesDS)return;
  const q=searchInput.value.trim().toLowerCase(),hits=[];
  procMap.forEach((p,id)=>{const s=`${p.meta?.binary||''} ${p.meta?.pid||''}`.toLowerCase();
    if(q&&s.includes(q))hits.push(id);});
  const ups=[];
  nodesDS.forEach(n=>{
    if(n.hidden||n.id.endsWith('_in')||n.id.endsWith('_out'))return;
    const p=procMap.get(n.id),col=
      n.id===ROOT?rootCol():hits.includes(n.id)?hitCol():p.files.length?fileCol():normCol();
    ups.push({...n,color:col});
  });
  nodesDS.update(ups);
  edgesDS.forEach(e=>{if(!e.hidden)edgesDS.update({id:e.id,color:'#8e8e93',width:1.2})});
}
function paintPath(id){
  const upsN=[],upsE=[];
  let cur=id;
  while(cur&&cur!==ROOT){
    const par=procMap.get(cur)?.parent||ROOT;
    if(!nodesDS.get(cur)?.hidden)upsN.push({id:cur,color:pathCol()});
    if(!edgesDS.get(`${par}->${cur}`)?.hidden)upsE.push({id:`${par}->${cur}`,color:'#ff453a',width:2.6});
    cur=par;
  }
  upsN.push({id:ROOT,color:pathCol()});
  nodesDS.update(upsN);edgesDS.update(upsE);
}
const clearPath=()=>refreshColors();

function fileList(arr) {
  return (
    '<ul>' +
    arr.slice(0, 150).map(ev => {
      const { type, path } = info(ev);
      const cls =
        type === 'READ'  ? 'read'  :
        type === 'WRITE' ? 'write' : 'unknown';
      return `<li><span class="tag ${cls}">${type}</span>${esc(path)}</li>`;
    }).join('') +
    (arr.length > 150 ? '<li>â¦</li>' : '') +
    '</ul>'
  );
}

function rawList(arr) {
  return (
    '<ul>' +
    arr.slice(0, 150).map(ev =>
      `<li><pre>${esc(JSON.stringify(ev).slice(0, 240))}</pre></li>`
    ).join('') +
    (arr.length > 150 ? '<li>â¦</li>' : '') +
    '</ul>'
  );
}

/* ---------- extract type / path from a file event ------------------- */
function info(ev) {
  /* kprobe from tetragon â READ (4) / WRITE (2) */
  if (ev.process_kprobe) {
    const args = ev.process_kprobe.args || [];
    const path = args[0]?.file_arg?.path || 'unknown';
    const code = args[1]?.int_arg;
    return {
      type: code === 4 ? 'READ'
         : code === 2 ? 'WRITE'
         : 'UNKNOWN',
      path
    };
  }

  /* native file_event object */
  if (ev.file_event) {
    return {
      type: (ev.file_event.event_type || 'UNKNOWN').toUpperCase(),
      path: ev.file_event.path || 'unknown'
    };
  }

  return { type: 'UNKNOWN', path: 'unknown' };
}

/* ---------- details pane (with File / Net events) -------------------- */
function showDetails(id) {
  const proc = procMap.get(id);
  if (!proc) return;

  if (id === ROOT) {
    details.innerHTML =
      '<h2>Process Details</h2><p><b>systemd</b> (synthetic root)</p>';
    return;
  }

  const par = procMap.get(proc.parent) || procMap.get(ROOT);

  details.innerHTML = 
    `<h2>Process Details</h2>
    <dl>
      <dt>Name</dt>
      <dd><code>${esc(basename(proc.meta?.binary))}</code>
          <span class="pid-badge">(PID ${proc.meta?.pid ?? '?'})</span></dd>

      <dt>Command line</dt>
      <dd><code>${esc(proc.meta?.arguments || '')}</code></dd>

      <dt>Path</dt>
      <dd><code>${esc(proc.meta?.binary || '')}</code></dd>

      <dt>Parent</dt>
      <dd><code>${esc(par.meta?.binary || ROOT)}</code>
          (PID ${par.meta?.pid ?? 0})</dd>

      <dt>Started</dt>
      <dd>${proc.meta?.start_time || '?'}</dd>
    </dl>

    ${proc.files.length
        ? `<details class="event-group" open>
             <summary>File events (${proc.files.length})</summary>
             ${fileList(proc.files)}
           </details>`
        : ''}

    ${proc.nets.length
        ? `<details class="event-group" open>
             <summary>Network events (${proc.nets.length})</summary>
             ${rawList(proc.nets)}
           </details>`
        : ''}`
  ;
}

</script>
</body>
</html>